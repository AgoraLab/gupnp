#! /usr/bin/python

# Copyright (C) 2008 OpenedHand Ltd
# Copyright (C) 2008 Intel Corporation
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 51 Franklin
# St, Fifth Floor, Boston, MA 02110-1301 USA

# TODO:
# - finish code cleanup

import sys, os.path, re, xml.etree.ElementTree as ET
from optparse import OptionParser


# upnp type:     (C type,      GType,                     get function)
typemap = {
  'ui1':         ('guint ',    'G_TYPE_UINT',             'g_value_get_uint'),
  'ui2':         ('guint ',    'G_TYPE_UINT',             'g_value_get_uint'),
  'ui4':         ('guint ',    'G_TYPE_UINT',             'g_value_get_uint'),
  'i1':          ('gint' ,     'G_TYPE_INT',              'g_value_get_int'),
  'i2':          ('gint ',     'G_TYPE_INT',              'g_value_get_int'),
  'i4':          ('gint ',     'G_TYPE_INT',              'g_value_get_int'),
  'int':         ('gint ',     'G_TYPE_INT',              'g_value_get_int'),
  'r4':          ('gfloat ',   'G_TYPE_FLOAT',            'g_value_get_float'),
  'r8':          ('gdouble ',  'G_TYPE_DOUBLE',           'g_value_get_double'),
  'number':      ('gdouble ',  'G_TYPE_DOUBLE',           'g_value_get_double'),
  'fixed.14.4':  ('gdouble ',  'G_TYPE_DOUBLE',           'g_value_get_double'),
  'float':       ('gdouble ',  'G_TYPE_DOUBLE',           'g_value_get_double'),
  'char':        ('gchar ',    'G_TYPE_CHAR',             'g_value_get_char'),
  'string':      ('gchar *',   'G_TYPE_STRING',           'g_value_get_string'),
  'date':        ('gchar *',   'GUPNP_TYPE_DATE',         'g_value_get_string'),
  'dateTime':    ('gchar *',   'GUPNP_TYPE_DATE_TIME',    'g_value_get_string'),
  'dateTime.tz': ('gchar *',   'GUPNP_TYPE_DATE_TIME_TZ', 'g_value_get_string'),
  'time':        ('gchar *',   'GUPNP_TYPE_TIME',         'g_value_get_string'),
  'time.tz':     ('gchar *',   'GUPNP_TYPE_TIME_TZ',      'g_value_get_string'),
  'boolean':     ('gboolean ', 'G_TYPE_BOOLEAN',          'g_value_get_boolean'),
  'bin.base64':  ('gchar *',   'GUPNP_TYPE_BIN_BASE64',   'g_value_get_string'),
  'bin.hex':     ('gchar *',   'GUPNP_TYPE_BIN_HEX',      'g_value_get_string'),
  'uri':         ('gchar *',   'GUPNP_TYPE_URI',          'g_value_get_string'),
  'uuid':        ('gchar *',   'GUPNP_TYPE_UUID',         'g_value_get_string')
}


class Action:
    def __init__(self):
        self.name = None
        self.c_name = None
        self.in_args = []
        self.out_args = []
        self.notify_vars = []


class Argument:
    def __init__(self):
        self.name = None
        self.c_name = None
        self.direction = None
        self.related_var = None


class Variable:
    def __init__(self):
        self.name = None
        self.c_name = None
        self.c_prefixed_name = None
        self.ctype = None
        self.gtype = None
        self.get_function = None


def camelCaseToLowerCase (str):
    # http://www.djangosnippets.org/snippets/585/
    tmp = re.sub('(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))', '_\\1', str)
    lower_case = tmp.lower().strip('_')
    return re.sub('[^a-z0-9]', '_', lower_case)


def getActions(scpd, prefix, variables):
    """
    Parse the SCPD provided into a list of Action objects.
    """
    
    actions = []
    
    for actionElement in scpd.findall("{urn:schemas-upnp-org:service-1-0}actionList/{urn:schemas-upnp-org:service-1-0}action"):
        a = Action()
        actions.append(a)
        a.name = actionElement.find("{urn:schemas-upnp-org:service-1-0}name").text

        if a.name is None:
            raise Exception("No name found for action")
        a.c_name = prefix + camelCaseToLowerCase (a.name)
        
        for argElement in actionElement.findall("{urn:schemas-upnp-org:service-1-0}argumentList/{urn:schemas-upnp-org:service-1-0}argument"):
            arg = Argument()

            arg.name = argElement.find("{urn:schemas-upnp-org:service-1-0}name").text
            if arg.name is None:
                raise Exception("No name found for argument")
            arg.c_name = camelCaseToLowerCase (arg.name)
            
            var_name = argElement.find("{urn:schemas-upnp-org:service-1-0}relatedStateVariable").text
            for var in variables:
                if var.name == var_name:
                    arg.related_var = var
                    break
            if arg.related_var == None:
                raise Exception("%s: related state variable %s not found" % (arg.name, var_name))
            
            arg.direction = argElement.find("{urn:schemas-upnp-org:service-1-0}direction").text
            
            if arg.direction == "in":
                    a.in_args.append(arg)
            else:
                    a.out_args.append(arg)
        
    return actions


def getVariables(scpd, prefix):
    """
    Parse the SCPD xml into a list of Variable objects.
    """
    
    variables = []

    for varElement in scpd.findall("{urn:schemas-upnp-org:service-1-0}serviceStateTable/{urn:schemas-upnp-org:service-1-0}stateVariable"):
        var = Variable()
        variables.append(var)
        
        var.name = varElement.find("{urn:schemas-upnp-org:service-1-0}name").text
        var.c_name = camelCaseToLowerCase (var.name)
        var.c_prefixed_name = prefix + var.c_name
        var.notified = (varElement.attrib["sendEvents"] == "yes")
        
        dataType = varElement.find("{urn:schemas-upnp-org:service-1-0}dataType").text
        if not dataType in typemap:
            raise Exception("Unknown dataType %s" % data_type)
        (var.ctype, var.gtype, var.get_function) = typemap[dataType];
    
    return variables


def printClientSyncFunctionBinding(a):
    indent = (2 + len (a.c_name)) * " "

    print "static inline gboolean"
    print "%s (GUPnPServiceProxy *proxy," % a.c_name
    
    for arg in a.in_args:
        print "%s%sin_%s," % (indent, arg.related_var.ctype, arg.c_name)
        
    for arg in a.out_args:
        print "%s%s*out_%s," % (indent, arg.related_var.ctype, arg.c_name)
        
    print "%sGError **error)" % indent
    
    print "{"

    print "  return gupnp_service_proxy_send_action"
    print "    (proxy, \"%s\", error, " % a.name
    
    for arg in a.in_args:
        print "     \"%s\", %s, in_%s," % (arg.name, arg.related_var.gtype, arg.c_name)
    print "     NULL, "
    
    for arg in a.out_args:
        print "     \"%s\", %s, out_%s," % (arg.name, arg.related_var.gtype, arg.c_name)
    print "     NULL);"
    
    print "}\n"


def printClientAsyncFunctionBinding(a):
    # Magic struct to pass data around.  Defined here so that we don't have
    # multiple copies of the struct definition.
    asyncdata = "  struct {GCallback cb; gpointer userdata; } *cbdata;"

    # User-callback prototype
    indent = (24 + len (a.c_name)) * " "
    print "typedef void (*%s_reply) (GUPnPServiceProxy *proxy," % a.c_name
    for arg in a.out_args:
        print "%s%sout_%s," % (indent, arg.related_var.ctype, arg.c_name)
    print "%sGError *error," % indent
    print "%sgpointer userdata);" % indent
    print

    # Generated async callback handler, calls user-provided callback
    indent = (30 + len (a.c_name)) * " "
    print "static void _%s_async_callback (GUPnPServiceProxy *proxy," % a.c_name
    print "%sGUPnPServiceProxyAction *action," % indent
    print "%sgpointer user_data)" % indent
    print "{"
    print asyncdata
    print "  GError *error = NULL;"
    for arg in a.out_args:
        print "  %s%s;" % (arg.related_var.ctype, arg.c_name)
    print
    print "  cbdata = user_data;"
    print "  gupnp_service_proxy_end_action"
    print "    (proxy, action, &error,"
    for arg in a.out_args:
        print "     \"%s\", %s, &%s," % (arg.name, arg.related_var.gtype, arg.c_name)
    print "     NULL);"
    print "  ((%s_reply)cbdata->cb)" % a.c_name
    print "    (proxy,"
    for arg in a.out_args:
        print "     %s," % arg.c_name
    print "     error, cbdata->userdata);"
    print
    print "  g_slice_free1 (sizeof (*cbdata), cbdata);"
    print "}"
    print

    # Entry point
    indent = (8 + len (a.c_name)) * " "
    print "static inline GUPnPServiceProxyAction *"
    print "%s_async (GUPnPServiceProxy *proxy," % a.c_name
    for arg in a.in_args:
        print "%s%sin_%s," % (indent, arg.related_var.ctype, arg.c_name)
    print "%s%s_reply callback," % (indent, a.c_name)
    print "%sgpointer userdata)" % indent
    print "{"
    print "  GUPnPServiceProxyAction* action;"
    print asyncdata
    print
    print "  cbdata = g_slice_alloc (sizeof (*cbdata));"
    print "  cbdata->cb = G_CALLBACK (callback);"
    print "  cbdata->userdata = userdata;"
    print "  action = gupnp_service_proxy_begin_action"
    print "    (proxy, \"%s\"," % a.name
    print "     _%s_async_callback, cbdata," % a.c_name
    for arg in a.in_args:
        print "     \"%s\", %s, in_%s," % (arg.name, arg.related_var.gtype, arg.c_name)
    print "     NULL);"
    print
    print "  return action;"
    print "}"

def printClientVariableBinding(v):
    asyncdata = "  struct {GCallback cb; gpointer userdata; } *cbdata;"
    ctype = re.sub ("^gchar", "const gchar", v.ctype);
    
    # callback prototype
    indent = (22 + len (v.c_prefixed_name)) * " "
    print "typedef void"
    print "(*%s_changed_callback) (GUPnPServiceProxy *proxy," % v.c_prefixed_name
    print "%s%s%s," % (indent, ctype, v.c_name)
    print "%sgpointer userdata);" % indent
    print
    
    # private callback
    indent = (20 + len (v.c_prefixed_name)) * " "
    print "static void"
    print "_%s_changed_callback (GUPnPServiceProxy *proxy," % v.c_prefixed_name
    print "%sconst gchar *variable," % indent
    print "%sGValue *value," % indent
    print "%sgpointer userdata)" % indent
    print "{"
    print asyncdata
    print "  %s%s;" % (ctype, v.c_name)
    print
    print "  cbdata = userdata;"
    print "  %s = %s (value);" % (v.c_name, v.get_function)
    print "  ((%s_changed_callback)cbdata->cb)" % v.c_prefixed_name
    print "    (proxy,"
    print "     %s," % v.c_name
    print "     cbdata->userdata);"
    print
    print "  g_slice_free1 (sizeof (*cbdata), cbdata);"
    print "}"
    print
    
    # public notify_add function
    indent = (13 + len (v.c_prefixed_name)) * " "
    print "static inline gboolean"
    print "%s_add_notify (GUPnPServiceProxy *proxy," % v.c_prefixed_name
    print "%s%s_changed_callback callback," % (indent, v.c_prefixed_name)
    print "%sgpointer userdata)" % indent
    print "{"
    print asyncdata
    print
    print "  cbdata = g_slice_alloc (sizeof (*cbdata));"
    print "  cbdata->cb = G_CALLBACK (callback);"
    print "  cbdata->userdata = userdata;"
    print
    print "  return gupnp_service_proxy_add_notify"
    print "    (proxy,"
    print "     \"%s\"," % v.name
    print "     %s," % v.gtype
    print "     _%s_changed_callback," % v.c_prefixed_name
    print "     cbdata);"
    print "}"

def parseSCPD(scpd, prefix):
    if prefix != "":
        prefix = prefix + "_"
    
    variables = getVariables(scpd, prefix)
    actions = getActions(scpd, prefix, variables)
    
    return (actions, variables)


def printClientBindings(service_filename, prefix):
    if prefix == "":
        base = re.sub("[^a-zA-Z0-9]", "_", os.path.basename(service_filename))
        define = "GUPNP_GENERATED_CLIENT_BINDING_%s" % base.upper()
    else:
        define = "GUPNP_GENERATED_CLIENT_BINDING_%s" % prefix.upper()
    
    print "/* Generated by gupnp-binding-tool */"
    print
    print "#include <glib/gtypes.h>"
    print "#include <glib/gerror.h>"
    print "#include <libgupnp/gupnp-service-proxy.h>"
    print
    print "#ifndef %s" % define
    print "#define %s" % define
    print
    print "G_BEGIN_DECLS"
    
    (actions, variables) = parseSCPD (ET.parse(service_filename), prefix)
        
    for a in actions:
        print "\n/* action %s */\n" % a.name
        printClientSyncFunctionBinding(a)
        printClientAsyncFunctionBinding(a)
    for v in variables:
        if v.notified:
            print "\n/* state variable %s */\n" % v.name
            printClientVariableBinding(v)
    
    print
    print "G_END_DECLS"
    print
    print "#endif /* %s */" % define


def main ():
    parser = OptionParser("Usage: gupnp-binding-tool [options] service-filename")
    parser.add_option("-p", "--prefix", dest="prefix", 
                      metavar="PREFIX", default="",
                      help="set prefix for generated function names")
    parser.add_option("-m", "--mode", type="choice", dest="mode", 
                      metavar="MODE", default="client",
                      choices=("client", "server"),
                      help="select generation mode, 'client' or 'server'")
    
    (options, args) = parser.parse_args() 
    if len(args) != 1:
        parser.error("Expected 1 argument, got %d" % len(args))
    if (options.mode == "client"):
        printClientBindings(args[0], options.prefix)
    else:
        print raise Exception ("Not implemented yet")

if __name__ == "__main__":
    main()
