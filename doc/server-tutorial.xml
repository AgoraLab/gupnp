<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">

<chapter id="server-tutorial">
  <title>Writing a UPnP Service</title>

  <simplesect>
    <title>Introduction</title>
    <para>
      This chapter explains how to implement a UPnP service using GUPnP.  Some
      knowledge of UPnP is assumed.  For this example we will create a dummy
      UPnP-enabled GPS device.
    </para>
    <para>
      Before any code can be written, the device and services that it implement
      need to be described in XML.  Although this can be annoying as it
      interferes with writin real code, writing the device description is fairly
      trivial and writing the service description forces you to think about the
      interface your service exposes to the world.
    </para>
  </simplesect>

  <simplesect>
    <title>Defining the Device</title>
    <para>
      The first step is to write the <firstterm>device description</firstterm>
      file.  This is a short XML document which describes the device and what
      services it provides.  For the full details see the <ulink
      url="http://upnp.org/specs/arch/UPnP-DeviceArchitecture-v1.0.pdf">UPnP
      Device Architecture</ulink> specification, section 2.1.  This is the
      minimal device description file which is valid and useful:
    </para>
<programlisting>&lt;?xml version="1.0"?&gt;
&lt;root xmlns="urn:schemas-upnp-org:device-1-0"&gt;
  &lt;specVersion&gt;
    &lt;major&gt;1&lt;/major&gt;
    &lt;minor&gt;0&lt;/minor&gt;
  &lt;/specVersion&gt;
  
  &lt;device&gt;
    &lt;deviceType&gt;urn:openedhand-com:device:PositionDevice:1&lt;/deviceType&gt;
    &lt;friendlyName&gt;Dummy GPS Device&lt;/friendlyName&gt;
    &lt;manufacturer&gt;OpenedHand&lt;/manufacturer&gt;
    &lt;modelName&gt;Dummy GPS Device&lt;/modelName&gt;
    &lt;UDN&gt;uuid:dbf27fdf-8646-40bf-b507-8e4bd8c2e7aa&lt;/UDN&gt;
    
    &lt;serviceList&gt;
      &lt;service&gt;
	&lt;serviceType&gt;urn:openedhand-com:service:PositionSensor:1&lt;/serviceType&gt;
	&lt;serviceId&gt;urn:openedhand-com:serviceId:PositionSensor:1&lt;/serviceId&gt;
	&lt;SCPDURL&gt;/PositionSensor1.xml&lt;/SCPDURL&gt;
	&lt;controlURL&gt;/Control&lt;/controlURL&gt;
	&lt;eventSubURL&gt;/Events&lt;/eventSubURL&gt;
      &lt;/service&gt;
    &lt;/serviceList&gt;
  &lt;/device&gt;
&lt;/root&gt;</programlisting>
    <para>
      The <sgmltag>specVersion</sgmltag> tag defines what version of the UPnP
      Device Architecture the document conforms to.  At the time of writing the
      only version is 1.0.
    </para>
    <para>
      Next there is the root <sgmltag>device</sgmltag> tag.  This contains
      metadata about the device, lists the services it provides and any
      sub-devices present (this is not shown in the example).  The
      <sgmltag>deviceType</sgmltag> tag specifies the type of the device, UPnP
      defines a standard set of device types, but as there isn't a GPS device
      standardised we follow the rules in the specification to generate a custom
      device type.
    </para>
    <para>
      Next we have <sgmltag>friendlyName</sgmltag>,
      <sgmltag>manufacturer</sgmltag> and <sgmltag>modelName</sgmltag>.  The
      friendly name is a human-readable name for the device, the manufacturer
      and model name are self-explanatory.
    </para>
    <para>
      Next there is the UDN, or <firstterm>Unique Device Name</firstterm>.  This
      is a unique identifier which is unique for each device but persistent for
      a particular device.  Although it has to start with
      <literal>uuid:</literal> it doesn't have to be an UUID.  There are several
      alternatives here, for example it could be computed at built-time if the
      software will only be used on a single machine, or it could be calculated
      on first boot using the device's serial number or MAC address
    </para>
    <para>
      Finally we have the <sgmltag>serviceList</sgmltag> which describes all of
      the services this device provides.  Each service has a service type (again
      there are types defined for standardised services or you can create your
      own), service identifier, and three URLs.  The <sgmltag>SCPDURL</sgmltag>
      field specifies where the <firstterm>Service Control Protocol
      Document</firstterm> can be found, this describes the service in more
      detail and will be covered next.  Finally there are the control and event
      URLs, which need to be unique on the device and will be managed by GUPnP.
    </para>
  </simplesect>

  <simplesect>
    <title>Defining Services</title>
    <para>
      Write me.
    </para>
  </simplesect>

  <simplesect>
    <title>Implementing the Device</title>
    <para>
      Before starting to implement the device, some boilerplate code is needed
      to initialise GUPnP.  GLib types and threading needs to be initialised,
      and then a GUPnP context can be created using gupnp_context_new().
    </para>
    <programlisting>GUPnPContext *context;
/* Initialize required subsystems */
g_thread_init (NULL);
g_type_init ();
/* Create the GUPnP context with default host and port */
context = gupnp_context_new (NULL, NULL, 0, NULL);</programlisting>
    <para>
      UPnP uses HTTP to provide the device and service description files, so
      next we get GUPnP to publish them.  This is done with
      gupnp_context_host_path() which takes a local filename to send when a
      server path is requested.
    </para>
<programlisting>gupnp_context_host_path (context, "PositionDevice1.xml", "/PositionDevice1.xml");
gupnp_context_host_path (context, "PositionSensor1.xml", "/PositionSensor1.xml");</programlisting>
    <para>
      Next the root device can be created.  GUPnP requires a parsed device
      description to be passed to gupnp_root_device_new() so that has to be
      parsed using <literal>libxml2</literal>.
    </para>
    <programlisting>xmlDoc *doc;
GUPnPRootDevice *dev;
/* Parse the device description */
doc = xmlParseFile ("PositionDevice1.xml");
/* Create the root device object */
dev = gupnp_root_device_new (context, doc, "PositionDevice1.xml");
/* Free the document when root device is destroyed */
g_object_weak_ref (G_OBJECT (dev), (GWeakNotify) xmlFreeDoc, doc);
/* Activate the root device, so that it announces itself */
gupnp_root_device_set_available (dev, TRUE);</programlisting>
    <para>
      GUPnP scans the device description and any service description files it
      refers to, so if the main loop was entered the device and service would be
      available on the network, albeit with no functionality.  The remaining
      task is to implement the services.
    </para>
  </simplesect>

  <simplesect>
    <title>Implementing a Service</title>
    <para>
      To implement a service we first fetch the #GUPnPService from the root
      device using gupnp_device_info_get_service() (#GUPnPRootDevice is a
      subclass of #GUPnPDevice, which implements #GUPnPDeviceInfo).  This
      returns a #GUPnPServiceInfo which again is an interface, implemented by
      #GUPnPService (on the server) and #GUPnPServiceProxy (on the client).
    </para>
    <programlisting>GUPnPServiceInfo *service;
service = gupnp_device_info_get_service
  (GUPNP_DEVICE_INFO (dev), "urn:openedhand-com:service:PositionSensor:1");</programlisting>
    <para>
      #GUPnPService handles interacting with the network itself, leaving the
      implementation of the service itself to signal handlers that we need to
      connect.  There are two signals: #GUPnPService::action-invoked and
      #GUPnPService::query-variable.  #GUPnPService::action-invoked is emitted
      when a client invokes an action: the handler is passed a
      #GUPnPServiceAction object that identifies which action was invoked, and
      is used to return values using gupnp_service_action_set().
      #GUPnPService::query-variable is emitted whenever a client queries the
      value of a state variable: the handler is passed the variable name and a
      #GValue which should be set to the current value of the variable.
    </para>
    <para>
      There are two approaches that clients can take to handle these signals.
      They can either connect a single handler to #GUPnPService::action-invoked
      or #GUPnPService::query-variable and examine the arguments to decide what
      action to take.  Alternatively, handlers can be targetted at specific
      actions or variables by using the <firstterm>signal detail</firstterm>
      when connecting.  For example, this causes
      <function>on_set_name_action</function> to be called when the
      <function>SetName</function> action is invoked and
      <function>on_get_name_action</function> to be called when the
      <function>GetName</function> action is invoked.
    </para>
    <programlisting>char *name;

static void
on_get_name_action (GUPnPService *service, GUPnPServiceAction *action, gpointer user_data)
{
  gupnp_service_action_set (action, "CurrentName", G_TYPE_STRING, name, NULL);
}

static void
on_set_name_action (GUPnPService *service, GUPnPServiceAction *action, gpointer user_data)
{
  g_free (name);
  gupnp_service_action_get (action, "NewName", G_TYPE_STRING, &amp;name, NULL);
}

  ...
  g_signal_connect (service, "action-invoked::GetName", G_CALLBACK (on_get_name_action), NULL);
  g_signal_connect (service, "action-invoked::SetName", G_CALLBACK (on_set_name_action), NULL);</programlisting>
    <para>
      For services which have many actions and variables there is a convenience
      method gupnp_service_signals_autoconnect() which will automatically
      connect handlers to signals.
    </para>
  </simplesect>
</chapter>
